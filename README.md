# 🐳 프로젝트 빌드
```
./gradlew clean build -x test
docker-compose up --build -d
```

- ### Docker 실행 흐름
<hr>

> 1. Dockerfile에서 AWS S3로부터 .env, application.yml 다운로드
> 2. MySQL 컨테이너 기동 시 /docker-entrypoint-initdb.d/init.sql 로 더미 데이터 삽입

<br>
<br>



# 📌회원 프로필 목록 조회 api

- ### ✅ QueryDSL
<hr>

> 정렬(이름 가나다순, 조회순, 등록 최신순), 검색 조건 등을 유연하게 동적으로 처리하기 위해 사용하였습니다. 
나중에 정렬 조건들이 추가되거나 조합될 수 있는 상황이 있을 때 빠르게 대응할 수 있고, JPA 의 복잡한 동적 쿼리를 깔끔하게 해결할 수 있어 유지보수시에 좋을 것이라고 판단했습니다.

- ### ✅ 복합 인덱스 + Offset 페이징
<hr>

> cursor 방식의 페이징은 이전 페이지로의 이동이 어렵고, 무한 스크롤을 구현할 때 적합하다 생각했습니다. 
> 성능 저하의 우려는 있었지만, 복합 인덱스와 조합하여 충분히 대응 가능하다고 판단했습니다. 

- ### ⚙️ Redis 캐시를 적용하지 않은 이유
<hr>

> 정렬 조건이 자주 바뀌는 경우 캐싱 무효화 전략이 복잡해 질 수 있고, 저장된 캐시를 즉시 제거해야하는데 이것도 다 비용이라고 생각했습니다.

<br>
<br>

# 📌회원 프로필 상세 조회수 업데이트 api

- ### ✅ Redis + 배치 스케줄러
<hr>

> 상세 조회 요청마다 DB에 조회수를 업데이트하기 보다는, 배치 스케줄러를 통해 Redis에 저장된 조회수를 주기적으로 DB에 반영하였습니다.
> 이렇게 하면 DB I/O를 줄일 수 있고, In-Memory 기반이라 연산이 빠르며, 조회수 증가에 대한 동시성 문제를 해결할 수 있었습니다.
>> 조회수가 수익과 직결되는 구조였다면, 강한 일관성과 비관적 락 처리를 고려했을 텐데 정확하지 않아도 되는 지표라 판단하여 성능 중심의 구조를 선택하였습니다.

- ### ⚙️ JPQL을 사용하지 않은 이유
<hr>

> 처음에는 조회수 증가를 위해 JPQL을 활용하여 직접 DB 업데이트 방식으로 설계했습니다. 하지만 상세 페이지 진입 시마다 DB I/O가 발생하여
> 트래픽이 많아질 경우 성능 병목이 될 수 있다고 생각했습니다. 또한 동시성 이슈가 발생할 수 있다고 판단했습니다.

<br>
<br>

# 📌포인트 충전 api

- ### ✅ RestClient
<hr>

> RestTemplated은 deprecated 경고가 있고, WebClient는 비동기 기반이라 오히려 과하다고 생각했습니다.
> 그래서 RestClient를 사용하여 동기 방식으로 간단하게 외부 API를 호출하였습니다.

- ### ✅ Redis 기반 락 처리
<hr>

> 결제 요청을 동시에 여러 번 보내는 경우를 방지하기 위해 Redis 기반의 락을 사용, 30초 동안 락을 유지하도록 설정했습니다.
> 이 구조를 통해 서버의 상태 변화가 1회만 일어나도록 설계하였습니다.